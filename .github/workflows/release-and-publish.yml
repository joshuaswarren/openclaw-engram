name: Release and Publish

on:
  push:
    branches:
      - main

permissions:
  contents: write
  id-token: write
  pull-requests: read

concurrency:
  group: release-main
  cancel-in-progress: false

jobs:
  release:
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          registry-url: 'https://registry.npmjs.org'
          cache: npm

      - name: Sync with latest main before validation
        run: |
          git fetch origin main
          git checkout -B main origin/main

      - name: Capture release source SHA
        id: source_sha
        run: |
          echo "sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Install dependencies
        run: npm ci

      - name: Verify quality gates
        run: |
          npm run check-types
          npm test
          npm run build

      - name: Configure git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Resolve bump type from merged PR labels
        id: bump
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = "${{ steps.source_sha.outputs.sha }}";

            let bumpType = "patch";
            let prNumber = "";
            let labels = [];

            try {
              const prs = await github.request(
                "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
                {
                  owner,
                  repo,
                  commit_sha: sha,
                  mediaType: { previews: ["groot"] },
                }
              );

              const mergedPr = prs.data.find((pr) => pr.merged_at) ?? null;
              if (mergedPr) {
                prNumber = String(mergedPr.number);
                labels = (mergedPr.labels ?? [])
                  .map((l) => String(l.name || "").toLowerCase())
                  .filter(Boolean);
              }
            } catch (error) {
              core.warning(`Could not resolve merged PR labels for ${sha}: ${error}`);
            }

            if (labels.includes("major") || labels.includes("breaking-change")) {
              bumpType = "major";
            } else if (labels.includes("feature") || labels.includes("enhancement")) {
              bumpType = "minor";
            }

            core.info(
              `Release bump resolved: ${bumpType} (sha=${sha}${prNumber ? `, pr=#${prNumber}` : ""}${labels.length ? `, labels=${labels.join(",")}` : ""})`
            );
            core.setOutput("bump_type", bumpType);
            core.setOutput("pr_number", prNumber);
            core.setOutput("pr_labels_csv", labels.join(","));

      - name: Compute next version from tags
        id: version
        run: |
          SOURCE_MAIN_SHA=$(git rev-parse HEAD)
          echo "source_main_sha=${SOURCE_MAIN_SHA}" >> "$GITHUB_OUTPUT"

          EXISTING_TAG=""
          while IFS= read -r tag; do
            [ -z "${tag}" ] && continue
            if git cat-file -p "refs/tags/${tag}" | grep -Fq "source-main-sha: ${SOURCE_MAIN_SHA}"; then
              EXISTING_TAG="${tag}"
              break
            fi
          done < <(git for-each-ref refs/tags --format='%(refname:short)' | grep -E '^v')
          if [ -n "${EXISTING_TAG}" ]; then
            echo "tag_exists=true" >> "$GITHUB_OUTPUT"
            echo "tag_name=${EXISTING_TAG}" >> "$GITHUB_OUTPUT"
            echo "new_version=${EXISTING_TAG#v}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          LATEST_TAG=$(git tag --list 'v*' --sort=-v:refname \
            | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' \
            | head -n 1 || true)
          if [ -z "${LATEST_TAG}" ]; then
            LATEST_TAG="v0.0.0"
          fi
          BASE_VERSION="${LATEST_TAG#v}"
          MAJOR="${BASE_VERSION%%.*}"
          REST="${BASE_VERSION#*.}"
          MINOR="${REST%%.*}"
          PATCH="${REST##*.}"
          BUMP_TYPE="${{ steps.bump.outputs.bump_type }}"
          case "${BUMP_TYPE}" in
            major)
              NEXT_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEXT_VERSION="${MAJOR}.$((MINOR + 1)).0"
              ;;
            *)
              NEXT_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
              ;;
          esac
          echo "base_tag=${LATEST_TAG}" >> "$GITHUB_OUTPUT"
          echo "bump_type=${BUMP_TYPE}" >> "$GITHUB_OUTPUT"
          echo "tag_exists=false" >> "$GITHUB_OUTPUT"
          echo "tag_name=v${NEXT_VERSION}" >> "$GITHUB_OUTPUT"
          echo "new_version=${NEXT_VERSION}" >> "$GITHUB_OUTPUT"
          npm version "${NEXT_VERSION}" --no-git-tag-version --allow-same-version
          git add package.json package-lock.json
          if git diff --cached --quiet; then
            echo "::notice title=Release commit skipped::Version already matches v${NEXT_VERSION}; no package files changed."
          else
            git commit -m "chore(release): v${NEXT_VERSION} [skip ci]"
          fi

      - name: Create version tag on release commit
        if: steps.version.outputs.tag_exists != 'true'
        run: |
          git tag -a "${{ steps.version.outputs.tag_name }}" \
            -m "Release ${{ steps.version.outputs.tag_name }}" \
            -m "source-main-sha: ${{ steps.version.outputs.source_main_sha }}"

      - name: Push release tag
        if: steps.version.outputs.tag_exists != 'true'
        run: git push origin "refs/tags/${{ steps.version.outputs.tag_name }}"

      - name: Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag_name }}
          name: ${{ steps.version.outputs.tag_name }}
          generate_release_notes: true

      - name: Checkout release tag source for publish
        run: git checkout --detach "${{ steps.version.outputs.tag_name }}"

      - name: Install dependencies for tagged source
        run: npm ci

      - name: Publish to npm (trusted publishing)
        run: |
          VERSION="${{ steps.version.outputs.new_version }}"
          PACKAGE_NAME="$(node -p "require('./package.json').name")"
          if npm view "${PACKAGE_NAME}@${VERSION}" version >/dev/null 2>&1; then
            echo "::notice title=NPM publish skipped::${PACKAGE_NAME}@${VERSION} is already published."
            exit 0
          fi
          npm publish --access public
